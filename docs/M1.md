# M1 — Shared Protocol Contract

## 1. Context

All components of the Chess AI system — the **React frontend**, **Rust engine**, and optional **WASM or remote server layer** — communicate using a consistent set of messages and data structures.
This milestone defines the **protocol schema** that allows both TypeScript and Rust sides to serialize and validate engine requests, progress events, and results.

The goal is to freeze the contract early to enable parallel work on the engine (M2–M4) and frontend (M6) without breaking interfaces.

---

## 2. Functional Scope

- Define a **versioned protocol** (`PROTOCOL_VERSION = "1.0.0"`).
- Specify message types:
  - `AnalyzeRequest`
  - `SearchInfo`
  - `BestMove`
  - `EngineOptions`
  - `Score`
  - `SearchLimit`
- Implement schemas and type guards in **TypeScript** using **Zod**.
- Mirror equivalent data structures in **Rust** using **serde**.
- Define wire format (JSON UTF-8).
- Ensure forward- and backward-compatible extension fields.

---

## 3. Non-Functional Requirements

| Property             | Requirement                                        |
| -------------------- | -------------------------------------------------- |
| **Language parity**  | 100 % field match between TS ↔ Rust structs       |
| **Validation speed** | < 0.5 ms per object on modern CPU                  |
| **Stability**        | No breaking changes after 1.0.0                    |
| **Schema size**      | Compact JSON, no binary blobs                      |
| **Error handling**   | All messages must carry error details when failing |

---

## 4. Technical Design

### 4.1 Structure

packages/protocol/ # TypeScript package
├── src/types.ts # TS interfaces
├── src/schema.ts # Zod validators
└── tests/roundtrip.test.ts
crates/engine/src/types.rs # Rust mirror structs

### 4.2 Core Message Flow

1.  The client sends `AnalyzeRequest`:

    ```json
    { "id": "uuid", "fen": "...", "limit": {"kind":"depth","depth":8} }

     2. The server streams back SearchInfo events:
    { "type": "searchInfo", "payload": { "depth": 3, "score": {"kind":"cp","value":12}, ... } }
    ```

        3. When done, the server emits a final BestMove:

    { "type": "bestMove", "payload": { "best": "e2e4", "ponder": "e7e5" } }

    ##4.3 Serialization
    • Rust: serde_json with camelCase field names.
    • TS: Zod validation on message receive; safeParse wrapper for error resilience.

4.4 Versioning Strategy
• PROTOCOL_VERSION embedded in both packages.
• Minor updates (1.x) may add optional fields; breaking changes trigger 2.0.
• Server advertises its version via /health endpoint.

4.5 Error Messages

{ "type": "error", "payload": { "id": "uuid", "message": "description" } }

5. Risks and mitigations

Risk
Mitigation
Drift between TS and Rust schemas
Generate JSON Schema from TS, verify with Rust tests
Missing backward compatibility
Unit tests across versions
Invalid WS payloads
Runtime Zod validation in client

6. Testing Plan

   • Unit tests:
   • TS ↔ Rust JSON round-trip.
   • Zod validation of valid/invalid messages.
   • Integration test:
   • End-to-end flow using fake server (see M7).
   • Schema check:
   • CI job comparing generated JSON Schemas. 7. Definition of Done

✅ @chess-ai/protocol builds successfully and exports types + schemas.
✅ cargo test in engine verifies Rust struct compatibility.
✅ JSON round-trip tests pass on CI.
✅ Protocol version 1.0.0 declared immutable until next major.
